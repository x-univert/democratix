{
    "buildInfo": {
        "rustc": {
            "version": "1.93.0-nightly",
            "commitHash": "d5419f1e97b90741d51841f800d3c697c662567d",
            "commitDate": "2025-10-30",
            "channel": "Nightly",
            "short": "rustc 1.93.0-nightly (d5419f1e9 2025-10-30)"
        },
        "contractCrate": {
            "name": "voting",
            "version": "0.1.0"
        },
        "framework": {
            "name": "multiversx-sc",
            "version": "0.62.0"
        }
    },
    "docs": [
        "Smart Contract de Vote",
        "",
        "Ce contrat gère la création d'élections, le vote et le stockage des votes chiffrés."
    ],
    "name": "VotingContract",
    "constructor": {
        "inputs": [],
        "outputs": []
    },
    "upgradeConstructor": {
        "docs": [
            "Fonction appelée lors de l'upgrade du contrat"
        ],
        "inputs": [],
        "outputs": []
    },
    "endpoints": [
        {
            "docs": [
                "Crée une nouvelle élection",
                "",
                "# Arguments",
                "* `title` - Titre de l'élection",
                "* `description_ipfs` - Hash IPFS de la description complète",
                "* `start_time` - Timestamp de début",
                "* `end_time` - Timestamp de fin",
                "* `requires_registration` - Inscription obligatoire ou non",
                "* `encryption_type` - Type de chiffrement: 0=none, 1=elgamal, 2=elgamal+zksnark",
                "* `registration_deadline` - Date limite d'inscription (optionnel)"
            ],
            "name": "createElection",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "title",
                    "type": "bytes"
                },
                {
                    "name": "description_ipfs",
                    "type": "bytes"
                },
                {
                    "name": "start_time",
                    "type": "u64"
                },
                {
                    "name": "end_time",
                    "type": "u64"
                },
                {
                    "name": "requires_registration",
                    "type": "bool"
                },
                {
                    "name": "encryption_type",
                    "type": "u8"
                },
                {
                    "name": "registration_deadline",
                    "type": "optional<u64>",
                    "multi_arg": true
                }
            ],
            "outputs": [
                {
                    "type": "u64"
                }
            ]
        },
        {
            "docs": [
                "Ajoute un candidat à une élection"
            ],
            "name": "addCandidate",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "candidate_id",
                    "type": "u32"
                },
                {
                    "name": "name",
                    "type": "bytes"
                },
                {
                    "name": "description_ipfs",
                    "type": "bytes"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Inscription d'un électeur à une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "Ajoute des adresses à la liste blanche d'une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `addresses` - Liste d'adresses à ajouter"
            ],
            "name": "addToWhitelist",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "addresses",
                    "type": "variadic<Address>",
                    "multi_arg": true
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Retire des adresses de la liste blanche"
            ],
            "name": "removeFromWhitelist",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "addresses",
                    "type": "variadic<Address>",
                    "multi_arg": true
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Génère des codes d'invitation pour une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `count` - Nombre de codes à générer",
                "* `batch_offset` - Offset de départ pour éviter les doublons entre batches (0 pour le premier batch, 100 pour le deuxième, etc.)"
            ],
            "name": "generateInvitationCodes",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "count",
                    "type": "u32"
                },
                {
                    "name": "batch_offset",
                    "type": "u32"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<bytes>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Inscription avec un code d'invitation",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `invitation_code` - Code d'invitation"
            ],
            "name": "registerWithInvitationCode",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "invitation_code",
                    "type": "bytes"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Soumet un vote chiffré",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `voting_token` - Token de vote (vérifié avec voter-registry)",
                "* `encrypted_vote` - Vote chiffré"
            ],
            "name": "castVote",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "_voting_token",
                    "type": "bytes"
                },
                {
                    "name": "encrypted_vote",
                    "type": "EncryptedVote"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Soumet un vote privé avec preuve zk-SNARK vérifiée off-chain",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `vote_commitment` - Commitment Poseidon du vote",
                "* `nullifier` - Nullifier unique pour empêcher le double vote",
                "* `backend_signature` - Signature du backend après vérification de la preuve",
                "",
                "# Sécurité",
                "- La preuve zk-SNARK est vérifiée off-chain par le backend",
                "- Le backend signe les données pour autoriser la transaction",
                "- Le nullifier empêche tout double vote"
            ],
            "name": "submitPrivateVote",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "vote_commitment",
                    "type": "bytes"
                },
                {
                    "name": "nullifier",
                    "type": "bytes"
                },
                {
                    "name": "backend_signature",
                    "type": "bytes"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Définit la clé publique ElGamal pour une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `public_key` - Clé publique ElGamal (hex string de la clé secp256k1)",
                "",
                "# Sécurité",
                "- Seul l'organisateur peut définir la clé publique",
                "- La clé doit être définie avant l'activation de l'élection"
            ],
            "name": "setElectionPublicKey",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "public_key",
                    "type": "bytes"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Récupère la clé publique ElGamal d'une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "",
                "# Returns",
                "La clé publique ElGamal (hex string) ou buffer vide si non définie"
            ],
            "name": "getElectionPublicKey",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "bytes"
                }
            ]
        },
        {
            "docs": [
                "Soumet un vote chiffré avec ElGamal (Option 1)",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `c1` - Composante 1 du chiffrement ElGamal (r × G)",
                "* `c2` - Composante 2 du chiffrement ElGamal (r × pk + m × G)",
                "",
                "# Sécurité",
                "- Le vote est chiffré côté client avec la clé publique",
                "- Seul l'organisateur peut déchiffrer avec sa clé privée (off-chain)",
                "- Le smart contract empêche le double vote"
            ],
            "name": "submitEncryptedVote",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "c1",
                    "type": "bytes"
                },
                {
                    "name": "c2",
                    "type": "bytes"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "**OPTION 2: VOTE PRIVÉ CHIFFRÉ AVEC PREUVE ZK-SNARK**",
                "",
                "Soumet un vote privé chiffré ElGamal avec une preuve zk-SNARK Groth16",
                "prouvant que le vote est valide SANS révéler le choix du candidat.",
                "",
                "Cette méthode offre la SÉCURITÉ MAXIMALE:",
                "- Chiffrement ElGamal pour la confidentialité",
                "- Preuve zk-SNARK pour garantir la validité",
                "- Nullifier pour empêcher le double vote",
                "- Vérification on-chain de la preuve",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `c1` - Composante 1 du chiffrement ElGamal = hash(r)",
                "* `c2` - Composante 2 du chiffrement ElGamal = hash(r, publicKey, candidateId)",
                "* `nullifier` - Identifiant unique anti-double vote = hash(voterSecret, electionId)",
                "* `pi_a` - Première composante de la preuve Groth16 (point G1)",
                "* `pi_b` - Deuxième composante de la preuve Groth16 (point G2)",
                "* `pi_c` - Troisième composante de la preuve Groth16 (point G1)",
                "* `public_signals` - Signaux publics pour vérification [numCandidates, c1, c2, publicKey, nullifier, electionId]",
                "",
                "# Sécurité",
                "- Le vote est chiffré ElGamal (seul l'organisateur peut déchiffrer)",
                "- La preuve zk-SNARK garantit que:",
                "  1. Le candidateId est valide (< numCandidates)",
                "  2. Le chiffrement ElGamal est correct",
                "  3. Le nullifier est bien formé",
                "- Le smart contract vérifie la preuve ON-CHAIN via pairing check",
                "- Le nullifier empêche le double vote de manière anonyme",
                "",
                "# Workflow",
                "1. Frontend génère la preuve zk-SNARK (2-3 secondes)",
                "2. Transaction soumise au smart contract",
                "3. Smart contract vérifie la preuve Groth16",
                "4. Si valide, vote accepté et stocké",
                "5. Nullifier enregistré pour empêcher double vote"
            ],
            "name": "submitPrivateVoteWithProof",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "c1",
                    "type": "bytes"
                },
                {
                    "name": "c2",
                    "type": "bytes"
                },
                {
                    "name": "nullifier",
                    "type": "bytes"
                },
                {
                    "name": "pi_a",
                    "type": "G1Point"
                },
                {
                    "name": "pi_b",
                    "type": "G2Point"
                },
                {
                    "name": "pi_c",
                    "type": "G1Point"
                },
                {
                    "name": "public_signals",
                    "type": "List<bytes>"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Récupère tous les votes chiffrés ElGamal d'une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "",
                "# Returns",
                "Vecteur de tous les votes chiffrés",
                "",
                "# Note",
                "Cette view est utilisée par l'organisateur pour récupérer les votes",
                "et les déchiffrer off-chain après la clôture de l'élection"
            ],
            "name": "getEncryptedVotes",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<ElGamalVote>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "**OPTION 2: RÉCUPÉRER VOTES CHIFFRÉS AVEC PREUVE ZK-SNARK**",
                "",
                "Récupère tous les votes chiffrés ElGamal avec preuves zk-SNARK d'une élection",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "",
                "# Returns",
                "Vecteur de tous les votes chiffrés avec leurs preuves Groth16",
                "",
                "# Note",
                "Cette view est utilisée par:",
                "- L'organisateur pour récupérer les votes et les déchiffrer off-chain",
                "- Les auditeurs pour vérifier les preuves",
                "- Le frontend pour afficher les statistiques (sans révéler les choix)"
            ],
            "name": "getEncryptedVotesWithProof",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<ElGamalVoteWithProof>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Récupère les nullifiers utilisés pour une élection (Option 2)",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "",
                "# Returns",
                "Ensemble des nullifiers déjà utilisés",
                "",
                "# Note",
                "Permet de vérifier qu'un vote n'a pas déjà été soumis",
                "Sans révéler l'identité du voteur"
            ],
            "name": "getOption2Nullifiers",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<bytes>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Active une élection (changement de statut Pending -> Active)"
            ],
            "name": "activateElection",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Ferme une élection (changement de statut Active -> Closed)"
            ],
            "name": "closeElection",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Finalise une élection fermée avec les résultats finaux",
                "Cette fonction stocke les résultats on-chain de manière immuable et optionnellement le hash IPFS",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `results_ipfs_hash` - Hash IPFS des résultats détaillés (vide si pas d'IPFS)",
                "* `results` - Vec de CandidateResult (candidate_id, vote_count) - DOIT ÊTRE EN DERNIER"
            ],
            "name": "finalizeElection",
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "results_ipfs_hash",
                    "type": "bytes"
                },
                {
                    "name": "results",
                    "type": "variadic<multi<u32,u64>>",
                    "multi_arg": true
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Récupère les résultats finaux on-chain d'une élection finalisée"
            ],
            "name": "getFinalResults",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<multi<u32,u64>>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Récupère le hash IPFS des résultats détaillés"
            ],
            "name": "getResultsIpfsHash",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "optional<bytes>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Configure l'adresse du backend autorisé à vérifier les preuves zk-SNARK",
                "(admin seulement)"
            ],
            "name": "setBackendVerifier",
            "onlyOwner": true,
            "mutability": "mutable",
            "inputs": [
                {
                    "name": "address",
                    "type": "Address"
                }
            ],
            "outputs": []
        },
        {
            "docs": [
                "Obtenir l'adresse du backend vérificateur zk-SNARK"
            ],
            "name": "getBackendVerifier",
            "mutability": "readonly",
            "inputs": [],
            "outputs": [
                {
                    "type": "Address"
                }
            ]
        },
        {
            "name": "getElection",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "Election"
                }
            ]
        },
        {
            "name": "getTotalVotes",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "u64"
                }
            ]
        },
        {
            "name": "getTotalElections",
            "mutability": "readonly",
            "inputs": [],
            "outputs": [
                {
                    "type": "u64"
                }
            ]
        },
        {
            "name": "getCandidates",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<Candidate>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Fonction temporaire pour obtenir le nombre de votes par candidat",
                "NOTE: Dans un vrai système de vote chiffré, cette fonction ne devrait",
                "être disponible qu'après déchiffrement (après closeElection)"
            ],
            "name": "getCandidateVotes",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "candidate_id",
                    "type": "u32"
                }
            ],
            "outputs": [
                {
                    "type": "u64"
                }
            ]
        },
        {
            "docs": [
                "Vérifie si une adresse a déjà voté pour une élection"
            ],
            "name": "hasVoted",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "voter",
                    "type": "Address"
                }
            ],
            "outputs": [
                {
                    "type": "bool"
                }
            ]
        },
        {
            "docs": [
                "Vérifie si un électeur est inscrit à une élection"
            ],
            "name": "isVoterRegistered",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "voter",
                    "type": "Address"
                }
            ],
            "outputs": [
                {
                    "type": "bool"
                }
            ]
        },
        {
            "docs": [
                "Obtient le nombre d'électeurs inscrits pour une élection"
            ],
            "name": "getRegisteredVotersCount",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "u64"
                }
            ]
        },
        {
            "docs": [
                "Récupère la liste des électeurs inscrits (avec pagination)",
                "",
                "# Arguments",
                "* `election_id` - ID de l'élection",
                "* `offset` - Position de départ",
                "* `limit` - Nombre maximum d'adresses à retourner"
            ],
            "name": "getRegisteredVoters",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "offset",
                    "type": "u32"
                },
                {
                    "name": "limit",
                    "type": "u32"
                }
            ],
            "outputs": [
                {
                    "type": "variadic<Address>",
                    "multi_result": true
                }
            ]
        },
        {
            "docs": [
                "Obtient les statistiques d'inscription pour une élection"
            ],
            "name": "getRegistrationStats",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "RegistrationStats"
                }
            ]
        },
        {
            "docs": [
                "Récupère le nombre d'inscriptions pour un jour spécifique"
            ],
            "name": "getRegistrationsPerDay",
            "mutability": "readonly",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64"
                },
                {
                    "name": "day_start",
                    "type": "u64"
                }
            ],
            "outputs": [
                {
                    "type": "u32"
                }
            ]
        }
    ],
    "events": [
        {
            "identifier": "electionCreated",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "organizer",
                    "type": "Address",
                    "indexed": true
                }
            ]
        },
        {
            "identifier": "voteCast",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "timestamp",
                    "type": "u64"
                }
            ]
        },
        {
            "identifier": "privateVoteSubmitted",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "vote_commitment",
                    "type": "bytes"
                }
            ]
        },
        {
            "identifier": "encryptedVoteSubmitted",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "timestamp",
                    "type": "u64"
                }
            ]
        },
        {
            "identifier": "encryptedVoteWithProofSubmitted",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "nullifier",
                    "type": "bytes",
                    "indexed": true
                },
                {
                    "name": "timestamp",
                    "type": "u64"
                }
            ]
        },
        {
            "identifier": "voterRegistered",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "voter",
                    "type": "Address",
                    "indexed": true
                }
            ]
        },
        {
            "identifier": "electionClosed",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "total_votes",
                    "type": "u64"
                }
            ]
        },
        {
            "identifier": "electionFinalized",
            "inputs": [
                {
                    "name": "election_id",
                    "type": "u64",
                    "indexed": true
                },
                {
                    "name": "total_votes",
                    "type": "u64"
                }
            ]
        }
    ],
    "esdtAttributes": [],
    "hasCallback": false,
    "types": {
        "Candidate": {
            "type": "struct",
            "docs": [
                "Structure représentant un candidat"
            ],
            "fields": [
                {
                    "name": "id",
                    "type": "u32"
                },
                {
                    "name": "name",
                    "type": "bytes"
                },
                {
                    "name": "description_ipfs",
                    "type": "bytes"
                }
            ]
        },
        "ElGamalVote": {
            "type": "struct",
            "docs": [
                "Vote chiffré avec ElGamal (Option 1)",
                "Chiffrement sur courbe elliptique secp256k1"
            ],
            "fields": [
                {
                    "name": "c1",
                    "type": "bytes"
                },
                {
                    "name": "c2",
                    "type": "bytes"
                },
                {
                    "name": "timestamp",
                    "type": "u64"
                }
            ]
        },
        "ElGamalVoteWithProof": {
            "type": "struct",
            "docs": [
                "Vote chiffré ElGamal avec preuve zk-SNARK (Option 2)",
                "Combine le chiffrement ElGamal avec une preuve mathématique de validité"
            ],
            "fields": [
                {
                    "name": "c1",
                    "type": "bytes"
                },
                {
                    "name": "c2",
                    "type": "bytes"
                },
                {
                    "name": "nullifier",
                    "type": "bytes"
                },
                {
                    "name": "proof",
                    "type": "Groth16Proof"
                },
                {
                    "name": "timestamp",
                    "type": "u64"
                }
            ]
        },
        "Election": {
            "type": "struct",
            "docs": [
                "Structure représentant une élection"
            ],
            "fields": [
                {
                    "name": "id",
                    "type": "u64"
                },
                {
                    "name": "title",
                    "type": "bytes"
                },
                {
                    "name": "description_ipfs",
                    "type": "bytes"
                },
                {
                    "name": "organizer",
                    "type": "Address"
                },
                {
                    "name": "start_time",
                    "type": "u64"
                },
                {
                    "name": "end_time",
                    "type": "u64"
                },
                {
                    "name": "num_candidates",
                    "type": "u32"
                },
                {
                    "name": "status",
                    "type": "ElectionStatus"
                },
                {
                    "name": "total_votes",
                    "type": "u64"
                },
                {
                    "name": "requires_registration",
                    "type": "bool"
                },
                {
                    "name": "registered_voters_count",
                    "type": "u64"
                },
                {
                    "name": "registration_deadline",
                    "type": "Option<u64>"
                },
                {
                    "name": "encryption_type",
                    "type": "u8"
                }
            ]
        },
        "ElectionStatus": {
            "type": "enum",
            "docs": [
                "Statut d'une élection"
            ],
            "variants": [
                {
                    "name": "Pending",
                    "discriminant": 0
                },
                {
                    "name": "Active",
                    "discriminant": 1
                },
                {
                    "name": "Closed",
                    "discriminant": 2
                },
                {
                    "name": "Finalized",
                    "discriminant": 3
                }
            ]
        },
        "EncryptedVote": {
            "type": "struct",
            "docs": [
                "Vote chiffré"
            ],
            "fields": [
                {
                    "name": "encrypted_choice",
                    "type": "bytes"
                },
                {
                    "name": "proof",
                    "type": "bytes"
                },
                {
                    "name": "timestamp",
                    "type": "u64"
                }
            ]
        },
        "G1Point": {
            "type": "struct",
            "docs": [
                "Point sur courbe elliptique G1 (BN254)"
            ],
            "fields": [
                {
                    "name": "x",
                    "type": "bytes"
                },
                {
                    "name": "y",
                    "type": "bytes"
                }
            ]
        },
        "G2Point": {
            "type": "struct",
            "docs": [
                "Point sur courbe elliptique G2 (BN254) - Extension field"
            ],
            "fields": [
                {
                    "name": "x1",
                    "type": "bytes"
                },
                {
                    "name": "x2",
                    "type": "bytes"
                },
                {
                    "name": "y1",
                    "type": "bytes"
                },
                {
                    "name": "y2",
                    "type": "bytes"
                }
            ]
        },
        "Groth16Proof": {
            "type": "struct",
            "docs": [
                "Preuve Groth16 pour zk-SNARK"
            ],
            "fields": [
                {
                    "name": "pi_a",
                    "type": "G1Point"
                },
                {
                    "name": "pi_b",
                    "type": "G2Point"
                },
                {
                    "name": "pi_c",
                    "type": "G1Point"
                }
            ]
        },
        "RegistrationStats": {
            "type": "struct",
            "docs": [
                "Statistiques d'inscription pour une élection"
            ],
            "fields": [
                {
                    "name": "total_registered",
                    "type": "u64"
                },
                {
                    "name": "last_registration_timestamp",
                    "type": "u64"
                }
            ]
        }
    }
}
